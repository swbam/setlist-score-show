// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
  output   = "../../../packages/database/generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core domain models
model Artist {
  id               String   @id @default(uuid())
  spotify_id       String?  @unique
  ticketmaster_id  String?
  setlistfm_mbid   String?  @unique
  name             String
  slug             String   @unique
  image_url        String?
  genres           String[]
  popularity       Int      @default(0)
  followers        Int      @default(0)
  last_synced_at   DateTime @default(now())
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  shows            Show[]
  songs            Song[]

  @@unique([spotify_id, ticketmaster_id], name: "unique_artist_ids")
  @@index([name])
  @@index([slug])
  @@map("artists")
}

model Venue {
  id               String   @id @default(uuid())
  ticketmaster_id  String?  @unique
  setlistfm_id     String?  @unique
  name             String
  address          String?
  city             String
  state            String?
  country          String
  postal_code      String?
  latitude         Decimal? @db.Decimal(10, 8)
  longitude        Decimal? @db.Decimal(11, 8)
  timezone         String?
  capacity         Int?
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  shows            Show[]

  @@index([city, state])
  @@index([name])
  @@map("venues")
}

model Show {
  id               String   @id @default(uuid())
  artist_id        String
  venue_id         String
  ticketmaster_id  String?  @unique
  setlistfm_id     String?  @unique
  date             DateTime @db.Date
  start_time       DateTime? @db.Time
  doors_time       DateTime? @db.Time
  title            String?
  tour_name        String?
  status           ShowStatus @default(upcoming)
  ticketmaster_url String?
  view_count       Int      @default(0)
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  artist           Artist   @relation(fields: [artist_id], references: [id], onDelete: Cascade)
  venue            Venue    @relation(fields: [venue_id], references: [id], onDelete: Cascade)
  setlists         Setlist[]
  votes            Vote[]
  vote_analytics   VoteAnalytics[]

  @@unique([artist_id, venue_id, date], name: "unique_show")
  @@index([date, status])
  @@index([artist_id, date])
  @@map("shows")
}

model Song {
  id               String   @id @default(uuid())
  artist_id        String
  spotify_id       String?  @unique
  musicbrainz_id   String?  @unique
  title            String
  album            String?
  album_image_url  String?
  duration_ms      Int?
  popularity       Int      @default(0)
  preview_url      String?
  spotify_url      String?
  audio_features   Json?
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  artist           Artist   @relation(fields: [artist_id], references: [id], onDelete: Cascade)
  setlist_songs    SetlistSong[]

  @@unique([artist_id, title, album], name: "unique_artist_song")
  @@index([title])
  @@index([artist_id])
  @@map("songs")
}

model Setlist {
  id               String   @id @default(uuid())
  show_id          String
  name             String   @default("Main Set")
  order_index      Int      @default(0)
  is_encore        Boolean  @default(false)
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  show             Show     @relation(fields: [show_id], references: [id], onDelete: Cascade)
  setlist_songs    SetlistSong[]

  @@unique([show_id, order_index], name: "unique_show_setlist")
  @@map("setlists")
}

model SetlistSong {
  id               String   @id @default(uuid())
  setlist_id       String
  song_id          String
  position         Int
  vote_count       Int      @default(0)
  notes            String?
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  setlist          Setlist  @relation(fields: [setlist_id], references: [id], onDelete: Cascade)
  song             Song     @relation(fields: [song_id], references: [id], onDelete: Cascade)
  votes            Vote[]

  @@unique([setlist_id, position], name: "unique_setlist_position")
  @@unique([setlist_id, song_id], name: "unique_setlist_song")
  @@index([vote_count])
  @@map("setlist_songs")
}

model User {
  id               String   @id
  email            String?
  display_name     String?
  avatar_url       String?
  spotify_id       String?  @unique
  preferences      Json     @default("{}")
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  votes            Vote[]
  vote_analytics   VoteAnalytics[]

  @@map("users")
}

model Vote {
  id               String   @id @default(uuid())
  user_id          String
  setlist_song_id  String
  show_id          String
  vote_type        VoteType @default(up)
  created_at       DateTime @default(now())

  // Relations
  user             User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  setlist_song     SetlistSong @relation(fields: [setlist_song_id], references: [id], onDelete: Cascade)
  show             Show     @relation(fields: [show_id], references: [id], onDelete: Cascade)

  @@unique([user_id, setlist_song_id], name: "unique_user_song_vote")
  @@index([user_id, created_at])
  @@map("votes")
}

model VoteAnalytics {
  id               String   @id @default(uuid())
  user_id          String
  show_id          String
  daily_votes      Int      @default(0)
  show_votes       Int      @default(0)
  last_vote_at     DateTime?
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  // Relations
  user             User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  show             Show     @relation(fields: [show_id], references: [id], onDelete: Cascade)

  @@unique([user_id, show_id], name: "unique_user_show_analytics")
  @@map("vote_analytics")
}

model SyncHistory {
  id               String   @id @default(uuid())
  sync_type        SyncType
  entity_type      EntityType
  entity_id        String?
  external_id      String?
  status           SyncStatus
  error_message    String?
  items_processed  Int      @default(0)
  started_at       DateTime @default(now())
  completed_at     DateTime?

  @@index([sync_type, entity_type, status])
  @@map("sync_history")
}

// Enums
enum ShowStatus {
  upcoming
  ongoing
  completed
  cancelled
}

enum VoteType {
  up
  down
}

enum SyncType {
  setlistfm
  spotify
  ticketmaster
}

enum EntityType {
  artist
  show
  song
  setlist
}

enum SyncStatus {
  started
  completed
  failed
}